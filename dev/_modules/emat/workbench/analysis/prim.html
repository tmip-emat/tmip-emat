

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>emat.workbench.analysis.prim &mdash; TMIP-EMAT 0.6.4, January 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/tmip_emat.css?v=eec227e2" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />

  
      <script src="../../../../_static/documentation_options.js?v=ff12c608"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/thebelab-helper.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            TMIP-EMAT
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.intro.html">Introduction to EMAT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.install.html">Installation and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.scope/index.html">Exploratory Scoping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.design/emat.design.html">Experimental Designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.models/index.html">Core Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.metamodels/index.html">Meta Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.database/index.html">Databases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.analysis/index.html">Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.method-index.html">Methodology Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/emat.references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">TMIP-EMAT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">emat.workbench.analysis.prim</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for emat.workbench.analysis.prim</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">A scenario discovery oriented implementation of PRIM.</span>

<span class="sd">The implementation of prim provided here is data type aware, so</span>
<span class="sd">categorical variables will be handled appropriately. It also uses a</span>
<span class="sd">non-standard objective function in the peeling and pasting phase of the</span>
<span class="sd">algorithm. This algorithm looks at the increase in the mean divided</span>
<span class="sd">by the amount of data removed. So essentially, it uses something akin</span>
<span class="sd">to the first order derivative of the original objective function.</span>

<span class="sd">The implementation is designed for interactive use in combination with</span>
<span class="sd">the jupyter notebook.</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">altair</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">alt</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">alt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># warnings.warn((&quot;altair based interactive &quot;</span>
    <span class="c1">#                &quot;inspection not available&quot;), ImportWarning)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..util</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">EMAError</span><span class="p">,</span> <span class="n">temporary_filter</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="n">get_module_logger</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">scenario_discovery_util</span> <span class="k">as</span> <span class="n">sdutil</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.prim_util</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">PrimException</span><span class="p">,</span> <span class="n">CurEntry</span><span class="p">,</span> <span class="n">PRIMObjectiveFunctions</span><span class="p">,</span>
                        <span class="n">NotSeen</span><span class="p">,</span> <span class="n">is_pareto_efficient</span><span class="p">,</span>
                        <span class="n">get_quantile</span><span class="p">,</span> <span class="n">rotate_subset</span><span class="p">,</span> <span class="n">calculate_qp</span><span class="p">,</span>
                        <span class="n">determine_dimres</span><span class="p">,</span> <span class="n">is_significant</span><span class="p">)</span>

<span class="c1"># Created on 22 feb. 2013</span>
<span class="c1">#</span>
<span class="c1"># .. codeauthor:: jhkwakkel &lt;j.h.kwakkel (at) tudelft (dot) nl&gt;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ABOVE&#39;</span><span class="p">,</span> <span class="s1">&#39;BELOW&#39;</span><span class="p">,</span> <span class="s1">&#39;setup_prim&#39;</span><span class="p">,</span> <span class="s1">&#39;Prim&#39;</span><span class="p">,</span> <span class="s1">&#39;PrimBox&#39;</span><span class="p">,</span>
           <span class="s2">&quot;pca_preprocess&quot;</span><span class="p">,</span> <span class="s2">&quot;run_constrained_prim&quot;</span><span class="p">,</span> <span class="s1">&#39;PRIMObjectiveFunctions&#39;</span><span class="p">]</span>
<span class="n">_logger</span> <span class="o">=</span> <span class="n">get_module_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">ABOVE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">BELOW</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">PRECISION</span> <span class="o">=</span> <span class="s1">&#39;.2f&#39;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pca_preprocess</span><span class="p">(</span><span class="n">experiments</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">subsets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;perform PCA to preprocess experiments before running PRIM</span>

<span class="sd">    Pre-process the data by performing a pca based rotation on it.</span>
<span class="sd">    This effectively turns the algorithm into PCA-PRIM as described</span>
<span class="sd">    in `Dalal et al (2013) &lt;http://www.sciencedirect.com/science/article/pii/S1364815213001345&gt;`_</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    experiments : DataFrame</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        one dimensional binary array</span>
<span class="sd">    subsets : dict, optional</span>
<span class="sd">              expects a dictionary with group name as key and a list of</span>
<span class="sd">              uncertainty names as values. If this is used, a constrained</span>
<span class="sd">              PCA-PRIM is executed</span>
<span class="sd">    exclude : list of str, optional</span>
<span class="sd">              the uncertainties that should be excluded from the rotation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rotated_experiments</span>
<span class="sd">        DataFrame</span>
<span class="sd">    rotation_matrix</span>
<span class="sd">        DataFrame</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError</span>
<span class="sd">        if mode is not binary (i.e. y is not a binary classification).</span>
<span class="sd">        if X contains non numeric columns</span>


<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># experiments to rotate</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">experiments</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;X includes non numeric columns&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">==</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;y should only contain 0s and 1s&#39;</span><span class="p">)</span>

    <span class="c1"># if no subsets are provided all uncertainties with non dtype object</span>
    <span class="c1"># are in the same subset, the name of this is r, for rotation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">subsets</span><span class="p">:</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO:: should we check on double counting in subsets?</span>
        <span class="c1">#        should we check all uncertainties are in x?</span>
        <span class="k">pass</span>

    <span class="c1"># prepare the dtypes for the new rotated experiments dataframe</span>
    <span class="n">new_columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_dtypes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">subsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># the names of the rotated columns are based on the group name</span>
        <span class="c1"># and an index</span>
        <span class="n">subset_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))]</span>
        <span class="n">new_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subset_cols</span><span class="p">)</span>
        <span class="n">new_dtypes</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="nb">float</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="c1"># make a new empty experiments dataframe</span>
    <span class="n">rotated_experiments</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">experiments</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">new_dtypes</span><span class="p">):</span>
        <span class="n">rotated_experiments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># put the uncertainties with object dtypes already into the new</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
        <span class="n">rotated_experiments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">experiments</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span>

    <span class="c1"># iterate over the subsets, rotate them, and put them into the new</span>
    <span class="c1"># experiments dataframe</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">row_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">subsets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">x_subset</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="n">subset_rotmat</span><span class="p">,</span> <span class="n">subset_experiments</span> <span class="o">=</span> <span class="n">rotate_subset</span><span class="p">(</span><span class="n">x_subset</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">rotation_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="o">=</span> <span class="n">subset_rotmat</span>
        <span class="n">row_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">rotated_experiments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset_experiments</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="p">[</span><span class="n">column_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>

    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">row_names</span><span class="p">,</span>
                                   <span class="n">columns</span><span class="o">=</span><span class="n">column_names</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rotated_experiments</span><span class="p">,</span> <span class="n">rotation_matrix</span>


<span class="k">def</span><span class="w"> </span><span class="nf">run_constrained_prim</span><span class="p">(</span><span class="n">experiments</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">issignificant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Run PRIM repeatedly while constraining the maximum number of dimensions</span>
<span class="sd">    available in x</span>

<span class="sd">    Improved usage of PRIM as described in `Kwakkel (2019) &lt;https://onlinelibrary.wiley.com/doi/full/10.1002/ffo2.8&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : numpy structured array</span>
<span class="sd">    y : numpy array</span>
<span class="sd">    issignificant : bool, optional</span>
<span class="sd">                    if True, run prim only on subsets of dimensions</span>
<span class="sd">                    that are significant for the initial PRIM on the</span>
<span class="sd">                    entire dataset.</span>
<span class="sd">    **kwargs : any additional keyword arguments are passed on to PRIM</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    PrimBox instance</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">frontier</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">merged_lims</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">merged_qp</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">alg</span> <span class="o">=</span> <span class="n">Prim</span><span class="p">(</span><span class="n">experiments</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">boxn</span> <span class="o">=</span> <span class="n">alg</span><span class="o">.</span><span class="n">find_box</span><span class="p">()</span>

    <span class="n">dims</span> <span class="o">=</span> <span class="n">determine_dimres</span><span class="p">(</span><span class="n">boxn</span><span class="p">,</span> <span class="n">issignificant</span><span class="o">=</span><span class="n">issignificant</span><span class="p">)</span>

    <span class="c1"># run prim for all possible combinations of dims</span>
    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;going to run PRIM </span><span class="si">{}</span><span class="s2"> times&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)))</span>

    <span class="n">boxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">boxn</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">temporary_filter</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">INFO</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">experiments</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">subset</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">alg</span> <span class="o">=</span> <span class="n">Prim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">alg</span><span class="o">.</span><span class="n">find_box</span><span class="p">()</span>
            <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>

    <span class="n">box_init</span> <span class="o">=</span> <span class="n">boxn</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">box_init</span>
    <span class="n">not_seen</span> <span class="o">=</span> <span class="n">NotSeen</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="n">boxes</span><span class="p">:</span>
        <span class="n">peeling</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">peeling_trajectory</span>
        <span class="n">lims</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span>

        <span class="n">logical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">lim</span> <span class="o">=</span> <span class="n">lims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">boxlim</span> <span class="o">=</span> <span class="n">box_init</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">lim</span><span class="p">:</span>
                <span class="n">boxlim</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">lim</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>

            <span class="n">boolean</span> <span class="o">=</span> <span class="n">is_significant</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">not_seen</span><span class="p">(</span><span class="n">boxlim</span><span class="p">)</span>

            <span class="n">logical</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">boolean</span>
            <span class="k">if</span> <span class="n">boolean</span><span class="p">:</span>
                <span class="n">merged_lims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">boxlim</span><span class="p">)</span>
                <span class="n">merged_qp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">qp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peeling</span><span class="p">[</span><span class="n">logical</span><span class="p">])</span>

    <span class="n">frontier</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">frontier</span><span class="p">)</span>

    <span class="c1"># remove dominated boxes</span>
    <span class="n">peeling_trajectory</span> <span class="o">=</span> <span class="n">frontier</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    <span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">logical</span> <span class="o">=</span> <span class="n">is_pareto_efficient</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># resort to ensure sensible ordering</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">peeling_trajectory</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s1">&#39;res_dim&#39;</span><span class="p">,</span> <span class="s1">&#39;coverage&#39;</span><span class="p">],</span>
                        <span class="n">ascending</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>

    <span class="n">box_lims</span> <span class="o">=</span> <span class="p">[</span><span class="n">lim</span> <span class="k">for</span> <span class="n">lim</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">merged_lims</span><span class="p">,</span> <span class="n">logical</span><span class="p">)</span> <span class="k">if</span> <span class="n">entry</span><span class="p">]</span>
    <span class="n">qps</span> <span class="o">=</span> <span class="p">[</span><span class="n">qp</span> <span class="k">for</span> <span class="n">qp</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">merged_qp</span><span class="p">,</span> <span class="n">logical</span><span class="p">)</span> <span class="k">if</span> <span class="n">entry</span><span class="p">]</span>
    <span class="n">sorted_lims</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_qps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">pt</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">sorted_lims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box_lims</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">entry</span><span class="p">)])</span>
        <span class="n">sorted_qps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qps</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">entry</span><span class="p">)])</span>

    <span class="c1"># ensuring index has normal order starting from 0</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pt</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">index</span>

    <span class="c1"># create PrimBox</span>
    <span class="n">box</span> <span class="o">=</span> <span class="n">PrimBox</span><span class="p">(</span><span class="n">boxn</span><span class="o">.</span><span class="n">prim</span><span class="p">,</span> <span class="n">boxn</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">box_init</span><span class="p">,</span> <span class="n">boxn</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span>
    <span class="n">box</span><span class="o">.</span><span class="n">peeling_trajectory</span> <span class="o">=</span> <span class="n">pt</span>
    <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span> <span class="o">=</span> <span class="n">sorted_lims</span>
    <span class="n">box</span><span class="o">.</span><span class="n">qp</span> <span class="o">=</span> <span class="n">sorted_qps</span>
    <span class="k">return</span> <span class="n">box</span>


<span class="k">def</span><span class="w"> </span><span class="nf">setup_prim</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">classify</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">incl_unc</span><span class="o">=</span><span class="p">[],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function for setting up the prim algorithm</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    results : tuple</span>
<span class="sd">              tuple of DataFrame and dict with numpy arrays</span>
<span class="sd">              the return from :meth:`perform_experiments`.</span>
<span class="sd">    classify : str or callable</span>
<span class="sd">               either a string denoting the outcome of interest to</span>
<span class="sd">               use or a function.</span>
<span class="sd">    threshold : double</span>
<span class="sd">                the minimum score on the density of the last box</span>
<span class="sd">                on the peeling trajectory. In case of a binary</span>
<span class="sd">                classification, this should be between 0 and 1.</span>
<span class="sd">    incl_unc : list of str, optional</span>
<span class="sd">               list of uncertainties to include in prim analysis</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">             valid keyword arguments for prim.Prim</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a Prim instance</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    PrimException</span>
<span class="sd">        if data resulting from classify is not a 1-d array.</span>
<span class="sd">    TypeError</span>
<span class="sd">        if classify is not a string or a callable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_setup</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">classify</span><span class="p">,</span> <span class="n">incl_unc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Prim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">PrimBox</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A class that holds information for a specific box</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    coverage : float</span>
<span class="sd">               coverage of currently selected box</span>
<span class="sd">    density : float</span>
<span class="sd">               density of currently selected box</span>
<span class="sd">    mean : float</span>
<span class="sd">           mean of currently selected box</span>
<span class="sd">    res_dim : int</span>
<span class="sd">              number of restricted dimensions of currently selected box</span>
<span class="sd">    mass : float</span>
<span class="sd">           mass of currently selected box</span>
<span class="sd">    peeling_trajectory : DataFrame</span>
<span class="sd">                         stats for each box in peeling trajectory</span>
<span class="sd">    box_lims : list</span>
<span class="sd">               list of box lims for each box in peeling trajectory</span>

<span class="sd">    by default, the currently selected box is the last box on the</span>
<span class="sd">    peeling trajectory, unless this is changed via</span>
<span class="sd">    :meth:`PrimBox.select`.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">coverage</span> <span class="o">=</span> <span class="n">CurEntry</span><span class="p">(</span><span class="s1">&#39;coverage&#39;</span><span class="p">)</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">CurEntry</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">CurEntry</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
    <span class="n">res_dim</span> <span class="o">=</span> <span class="n">CurEntry</span><span class="p">(</span><span class="s1">&#39;res_dim&#39;</span><span class="p">)</span>
    <span class="n">mass</span> <span class="o">=</span> <span class="n">CurEntry</span><span class="p">(</span><span class="s1">&#39;mass&#39;</span><span class="p">)</span>

    <span class="n">_frozen</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prim</span><span class="p">,</span> <span class="n">box_lims</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;init</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prim : Prim instance</span>
<span class="sd">        box_lims : DataFrame</span>
<span class="sd">        indices : ndarray</span>


<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prim</span> <span class="o">=</span> <span class="n">prim</span>

        <span class="c1"># peeling and pasting trajectory</span>
        <span class="n">colums</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;coverage&#39;</span><span class="p">,</span> <span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;res_dim&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">colums</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resampled</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yi_initial</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:]</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum&#39;</span><span class="p">,</span> <span class="s1">&#39;maximum&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;qp_lower&#39;</span><span class="p">,</span> <span class="s1">&#39;qp_upper&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boxes_quantitative</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;item&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;n_items&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boxes_nominal</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># indices van data in box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">box_lims</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        used here to give box_lim same behaviour as coverage, density,</span>
<span class="sd">        mean, res_dim, and mass. That is, it will return the box lim</span>
<span class="sd">        associated with the currently selected box.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;box_lim&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>

<div class="viewcode-block" id="PrimBox.inspect">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.inspect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;table&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Write the stats and box limits of the user specified box to</span>
<span class="sd">        standard out. if i is not provided, the last box will be</span>
<span class="sd">        printed</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int, optional</span>
<span class="sd">            the index of the box, defaults to currently selected box</span>
<span class="sd">        style : {&#39;table&#39;, &#39;graph&#39;}</span>
<span class="sd">                the style of the visualization</span>

<span class="sd">        additional kwargs are passed to the helper function that</span>
<span class="sd">        generates the table or graph</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span>

        <span class="n">stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;restricted_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;res_dim&#39;</span><span class="p">]</span>

        <span class="n">qp_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">uncs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">qp_values</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="n">uncs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">uncs</span> <span class="o">=</span> <span class="p">[</span><span class="n">uncs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">uncs</span> <span class="ow">in</span> <span class="n">uncs</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s1">&#39;table&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inspect_table</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">uncs</span><span class="p">,</span> <span class="n">qp_values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">style</span> <span class="o">==</span> <span class="s1">&#39;graph&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inspect_graph</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">uncs</span><span class="p">,</span> <span class="n">qp_values</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;style must be one of graph or table&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_inspect_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">uncs</span><span class="p">,</span> <span class="n">qp_values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Helper function for visualizing box statistics in</span>
<span class="sd">        table form&#39;&#39;&#39;</span>
        <span class="c1"># make the descriptive statistics for the box</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">()</span>

        <span class="c1"># make the box definition</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([[</span><span class="s1">&#39;box </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span>
                                              <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;qp values&#39;</span><span class="p">]])</span>
        <span class="n">box_lim</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">uncs</span><span class="p">),</span> <span class="mi">3</span><span class="p">)),</span>
                               <span class="n">index</span><span class="o">=</span><span class="n">uncs</span><span class="p">,</span>
                               <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">unc</span> <span class="ow">in</span> <span class="n">uncs</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">unc</span><span class="p">]</span>
            <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">unc</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">qp_values</span><span class="p">[</span><span class="n">unc</span><span class="p">])]</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">box_lim</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inspect_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">uncs</span><span class="p">,</span> <span class="n">qp_values</span><span class="p">,</span>
                       <span class="n">ticklabel_formatter</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="p">,</span>
                       <span class="n">boxlim_formatter</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{: .2g}</span><span class="s2">&quot;</span><span class="p">,</span>
                       <span class="n">table_formatter</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:.3g}</span><span class="s1">&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Helper function for visualizing box statistics in</span>
<span class="sd">        graph form&#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">plot_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qp_values</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">box_init</span><span class="p">,</span> <span class="n">uncs</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;coverage&#39;</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;density&quot;</span><span class="p">],</span>
                               <span class="n">ticklabel_formatter</span><span class="o">=</span><span class="n">ticklabel_formatter</span><span class="p">,</span>
                               <span class="n">boxlim_formatter</span><span class="o">=</span><span class="n">boxlim_formatter</span><span class="p">,</span>
                               <span class="n">table_formatter</span><span class="o">=</span><span class="n">table_formatter</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">inspect_tradeoff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO::</span>
        <span class="c1"># make legend with res_dim color code a selector as well?</span>
        <span class="c1"># https://medium.com/dataexplorations/focus-generating-an-interactive-legend-in-altair-9a92b5714c55</span>
        
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nominal_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quantitative_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x_float_colums</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x_int_columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">nominal_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x_nominal_columns</span><span class="p">)</span>

        <span class="n">box_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">qp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qp</span><span class="p">)):</span>
            <span class="n">qp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;qp_lower&#39;</span><span class="p">,</span> <span class="s1">&#39;qp_upper&#39;</span><span class="p">])</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">qp</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">quantitative_res_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">quantitative_dims</span><span class="p">]</span>
            <span class="n">nominal_res_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">dims</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">nominal_dims</span><span class="p">]</span>

            <span class="c1"># handle quantitative</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">entry</span>

            <span class="n">box</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">quantitative_res_dim</span><span class="p">]</span>
            <span class="n">box</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">]</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">T</span>
            <span class="n">box</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">index</span>
            <span class="n">box</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">box</span><span class="p">[</span><span class="s1">&#39;minimum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_zero</span><span class="p">[</span><span class="n">quantitative_res_dim</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">box</span><span class="p">[</span><span class="s1">&#39;maximum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_zero</span><span class="p">[</span><span class="n">quantitative_res_dim</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qp</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>

            <span class="c1"># handle nominal</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">nominal_res_dims</span><span class="p">:</span>
                <span class="c1"># TODO:: qp values</span>
                <span class="n">items</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
<span class="c1">#                     we need to have tick labeling to be dynamic?</span>
<span class="c1">#                     adding it to the dict wont work, creates horrible figure</span>
<span class="c1">#                     unless we can force a selection?</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">qp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">qp</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="si">:</span><span class="s2"> .2g</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">entry</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">n_items</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                 <span class="n">item</span><span class="o">=</span><span class="n">item</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                                 <span class="n">x</span><span class="o">=</span><span class="n">j</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
                    <span class="n">nominal_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

        <span class="n">boxes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">boxes</span><span class="p">)</span>
        <span class="n">nominal_vars</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">nominal_vars</span><span class="p">)</span>

        <span class="n">width</span> <span class="o">=</span> <span class="mi">400</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">width</span>

        <span class="n">point_selector</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">selection_single</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>

        <span class="n">peeling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">peeling</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peeling</span><span class="o">.</span><span class="n">index</span>

        <span class="n">chart</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">Chart</span><span class="p">(</span><span class="n">peeling</span><span class="p">)</span><span class="o">.</span><span class="n">mark_circle</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="mi">75</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="s1">&#39;coverage:Q&#39;</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="s1">&#39;density:Q&#39;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span>
                <span class="s1">&#39;res_dim:O&#39;</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span>
                        <span class="s1">&#39;YlGnBu&#39;</span><span class="p">,</span>
                        <span class="n">n_colors</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">as_hex</span><span class="p">())),</span>
            <span class="n">opacity</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span>
                <span class="n">point_selector</span><span class="p">,</span>
                <span class="n">alt</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">alt</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)))</span><span class="o">.</span><span class="n">properties</span><span class="p">(</span>
            <span class="n">selection</span><span class="o">=</span><span class="n">point_selector</span><span class="p">)</span><span class="o">.</span><span class="n">properties</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">)</span>

        <span class="c1"># conda update -c conda-forge altair to 2.1</span>
        <span class="c1"># move this to encoding tooltip=[&lt;list of items&gt;]</span>
        <span class="n">chart</span><span class="o">.</span><span class="n">encoding</span><span class="o">.</span><span class="n">tooltip</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ordinal&quot;</span><span class="p">,</span>
             <span class="s2">&quot;field&quot;</span><span class="p">:</span> <span class="s2">&quot;id&quot;</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;quantitative&quot;</span><span class="p">,</span>
             <span class="s2">&quot;field&quot;</span><span class="p">:</span> <span class="s2">&quot;coverage&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;.2&quot;</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;quantitative&quot;</span><span class="p">,</span>
             <span class="s2">&quot;field&quot;</span><span class="p">:</span> <span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;.2&quot;</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ordinal&quot;</span><span class="p">,</span> <span class="s2">&quot;field&quot;</span><span class="p">:</span> <span class="s2">&quot;res_dim&quot;</span><span class="p">,</span> <span class="p">}</span>
        <span class="p">]</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">Chart</span><span class="p">(</span><span class="n">boxes</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="s1">&#39;x_lower:Q&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Axis</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">title</span><span class="o">=</span><span class="s1">&#39;box limits&#39;</span><span class="p">,</span>
                                               <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)),</span>
            <span class="n">x2</span><span class="o">=</span><span class="s1">&#39;x_upper:Q&#39;</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="s1">&#39;name:N&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">transform_calculate</span><span class="p">(</span>
            <span class="n">x_lower</span><span class="o">=</span><span class="s1">&#39;(datum.x1-datum.minimum)/(datum.maximum-datum.minimum)&#39;</span><span class="p">,</span>
            <span class="n">x_upper</span><span class="o">=</span><span class="s1">&#39;(datum.x2-datum.minimum)/(datum.maximum-datum.minimum)&#39;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">transform_filter</span><span class="p">(</span>
            <span class="n">point_selector</span>
        <span class="p">)</span><span class="o">.</span><span class="n">properties</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">mark_rule</span><span class="p">()</span>

        <span class="n">texts1</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">mark_text</span><span class="p">(</span>
            <span class="n">baseline</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="s1">&#39;text:O&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">transform_calculate</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="p">(</span>
                <span class="s1">&#39;datum.qp_lower&gt;0?&#39;</span>
                <span class="s1">&#39;format(datum.x1, &quot;.2&quot;)+&quot; (&quot;+format(datum.qp_lower, &quot;.1~g&quot;)+&quot;)&quot; :&#39;</span>
                <span class="s1">&#39;format(datum.x1, &quot;.2&quot;)&#39;</span><span class="p">))</span>

        <span class="n">texts2</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">mark_text</span><span class="p">(</span>
            <span class="n">baseline</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="n">alt</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="s1">&#39;text:O&#39;</span><span class="p">),</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;x_upper:Q&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">transform_calculate</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="p">(</span>
                <span class="s1">&#39;datum.qp_upper&gt;0?&#39;</span>
                <span class="s1">&#39;format(datum.x2, &quot;.2&quot;)+&quot; (&quot;+format(datum.qp_upper, &quot;.1&quot;)+&quot;)&quot; :&#39;</span>
                <span class="s1">&#39;format(datum.x2, &quot;.2&quot;)&#39;</span><span class="p">))</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="nb">dict</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">Chart</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">mark_rect</span><span class="p">(</span><span class="n">opacity</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="s1">&#39;start:Q&#39;</span><span class="p">,</span>
            <span class="n">x2</span><span class="o">=</span><span class="s1">&#39;end:Q&#39;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># TODO:: for qp can we do something with the y encoding here and</span>
        <span class="c1"># connecting this to a selection?</span>
        <span class="c1"># seems tricky, no clear way to control the actual labels</span>
        <span class="c1"># or can we use the text channel identical to the above?</span>
        <span class="n">nominal</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">Chart</span><span class="p">(</span><span class="n">nominal_vars</span><span class="p">)</span><span class="o">.</span><span class="n">mark_point</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="s1">&#39;x:Q&#39;</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="s1">&#39;name:N&#39;</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">transform_filter</span><span class="p">(</span>
            <span class="n">point_selector</span>
        <span class="p">)</span><span class="o">.</span><span class="n">properties</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">texts3</span> <span class="o">=</span> <span class="n">nominal</span><span class="o">.</span><span class="n">mark_text</span><span class="p">(</span><span class="n">baseline</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span>
                                   <span class="n">dy</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="s1">&#39;item:N&#39;</span>
        <span class="p">)</span>

        <span class="n">layered</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">layer</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">texts1</span><span class="p">,</span> <span class="n">texts2</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">nominal</span><span class="p">,</span>
                            <span class="n">texts3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">chart</span> <span class="o">&amp;</span> <span class="n">layered</span>

<div class="viewcode-block" id="PrimBox.resample">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.resample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Calculate resample statistics for candidate box i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int, optional</span>
<span class="sd">        iterations : int, optional</span>
<span class="sd">        p : float, optional</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yi_initial</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yi_initial</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_resampled</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">temporary_filter</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;find_box&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_resampled</span><span class="p">),</span> <span class="n">iterations</span><span class="p">):</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;resample </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">),</span>
                                             <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">x_temp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">y_temp</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

                    <span class="n">box</span> <span class="o">=</span> <span class="n">Prim</span><span class="p">(</span><span class="n">x_temp</span><span class="p">,</span> <span class="n">y_temp</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                               <span class="n">peel_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">peel_alpha</span><span class="p">,</span>
                               <span class="n">paste_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">paste_alpha</span><span class="p">)</span><span class="o">.</span><span class="n">find_box</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_resampled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>

        <span class="n">counters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="p">{</span><span class="n">column</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span><span class="p">}</span>
            <span class="n">counters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>

        <span class="n">coverage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">coverage</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">density</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resampled</span><span class="p">:</span>
            <span class="n">coverage_index</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">box</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">coverage</span> <span class="o">-</span>
                <span class="n">coverage</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
            <span class="n">density_index</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">box</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">density</span> <span class="o">-</span>
                <span class="n">density</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">counters</span><span class="p">,</span> <span class="p">[</span><span class="n">coverage_index</span><span class="p">,</span>
                                                 <span class="n">density_index</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">unc</span> <span class="ow">in</span> <span class="n">box</span><span class="o">.</span><span class="n">qp</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">counter</span><span class="p">[</span><span class="n">unc</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">iterations</span>

        <span class="n">scores</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">counters</span><span class="p">,</span>
                              <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;reproduce coverage&#39;</span><span class="p">,</span>
                                     <span class="s1">&#39;reproduce density&#39;</span><span class="p">],</span>
                              <span class="n">columns</span><span class="o">=</span><span class="n">box</span><span class="o">.</span><span class="n">box_lim</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="k">return</span> <span class="n">scores</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;reproduce coverage&#39;</span><span class="p">,</span>
                                      <span class="s1">&#39;reproduce density&#39;</span><span class="p">],</span>
                                  <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        select an entry from the peeling and pasting trajectory and</span>
<span class="sd">        update the prim box to this selected box.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            the index of the box to select.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PrimException</span><span class="p">((</span><span class="s2">&quot;box has been frozen because PRIM &quot;</span>
                                 <span class="s2">&quot;has found at least one more recent &quot;</span>
                                 <span class="s2">&quot;box&quot;</span><span class="p">))</span>

        <span class="n">res_dim</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_determine_restricted_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">box_init</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_in_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">,</span>
                                                 <span class="n">res_dim</span><span class="p">],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">res_dim</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span> <span class="o">=</span> <span class="n">i</span>

<div class="viewcode-block" id="PrimBox.drop_restriction">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.drop_restriction">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">drop_restriction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncertainty</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Drop the restriction on the specified dimension for box i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int, optional</span>
<span class="sd">            defaults to the currently selected box, which</span>
<span class="sd">            defaults to the latest box on the trajectory</span>
<span class="sd">        uncertainty : str</span>


<span class="sd">        Replace the limits in box i with a new box where</span>
<span class="sd">        for the specified uncertainty the limits of the initial box are</span>
<span class="sd">        being used. The resulting box is added to the peeling trajectory.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span>

        <span class="n">new_box_lim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">uncertainty</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">uncertainty</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_in_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">,</span> <span class="p">:],</span>
                                 <span class="n">new_box_lim</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_box_lim</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span></div>


<div class="viewcode-block" id="PrimBox.update">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_lims</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;update the box to the provided box limits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box_lims: DataFrame</span>
<span class="sd">                  the new box_lims</span>
<span class="sd">        indices: ndarray</span>
<span class="sd">                 the indices of y that are inside the box</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box_lims</span><span class="p">)</span>

        <span class="c1"># peeling trajectory</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">]</span>
        <span class="n">coi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">determine_coi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span>

        <span class="n">restricted_dims</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_determine_restricted_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">box_init</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;coverage&#39;</span><span class="p">:</span> <span class="n">coi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">t_coi</span><span class="p">,</span>
                <span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="n">coi</span> <span class="o">/</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
                <span class="s1">&#39;res_dim&#39;</span><span class="p">:</span> <span class="n">restricted_dims</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;mass&#39;</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>
        <span class="n">new_row</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">data</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">new_row</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># boxlims</span>
        <span class="n">qp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_quasi_p</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">restricted_dims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="PrimBox.show_ppt">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.show_ppt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">show_ppt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;show the peeling and pasting trajectory in a figure&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">plot_ppt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="p">)</span></div>


<div class="viewcode-block" id="PrimBox.show_tradeoff">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.show_tradeoff">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">show_tradeoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">):</span>  <span class="c1"># @UndefinedVariable</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Visualize the trade off between coverage and density. Color</span>
<span class="sd">        is used to denote the number of restricted dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cmap : valid matplotlib colormap</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a Figure instance</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">plot_tradeoff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span></div>


<div class="viewcode-block" id="PrimBox.show_pairs_scatter">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.show_pairs_scatter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">show_pairs_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Make a pair wise scatter plot of all the restricted</span>
<span class="sd">        dimensions with color denoting whether a given point is of</span>
<span class="sd">        interest or not and the boxlims superimposed on top.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int, optional</span>
<span class="sd">        dims : list of str, optional</span>
<span class="sd">               dimensions to show, defaults to all restricted dimensions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        seaborn PairGrid</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cur_box</span>

        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_determine_restricted_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">box_init</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">plot_pair_wise_scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yi_initial</span><span class="p">,:],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yi_initial</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">box_init</span><span class="p">,</span>
                                             <span class="n">dims</span><span class="p">,</span>
                                             <span class="n">markers</span><span class="o">=</span><span class="n">markers</span><span class="p">)</span></div>


<div class="viewcode-block" id="PrimBox.write_ppt_to_stdout">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.PrimBox.write_ppt_to_stdout">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_ppt_to_stdout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;write the peeling and pasting trajectory to stdout&#39;&#39;&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_quasi_p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">restricted_dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;helper function for calculating quasi-p values as discussed</span>
<span class="sd">        in Bryant and Lempert (2010). This is a one sided  binomial</span>
<span class="sd">        test.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">            the specific box in the peeling trajectory for which the</span>
<span class="sd">            quasi-p values are to be calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">box_lim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">box_lim</span> <span class="o">=</span> <span class="n">box_lim</span><span class="p">[</span><span class="n">restricted_dims</span><span class="p">]</span>

        <span class="c1"># total nr. of cases in box</span>
        <span class="n">Tbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">n</span>

        <span class="c1"># total nr. of cases of interest in box</span>
        <span class="n">Hbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peeling_trajectory</span><span class="p">[</span><span class="s1">&#39;coverage&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">t_coi</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">,</span> <span class="n">restricted_dims</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">]</span>

        <span class="c1"># TODO use apply on df?</span>

        <span class="n">qp_values</span> <span class="o">=</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">calculate_qp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">result_type</span><span class="o">=</span><span class="s1">&#39;expand&#39;</span><span class="p">,</span>
                                  <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">Hbox</span><span class="p">,</span> <span class="n">Tbox</span><span class="p">,</span> <span class="n">box_lim</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">qp_values</span> <span class="o">=</span> <span class="n">qp_values</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qp_values</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Prim</span><span class="p">(</span><span class="n">sdutil</span><span class="o">.</span><span class="n">OutputFormatterMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Patient rule induction algorithm</span>

<span class="sd">    The implementation of Prim is tailored to interactive use in the</span>
<span class="sd">    context of scenario discovery</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : DataFrame</span>
<span class="sd">        the independent variables</span>
<span class="sd">    y : 1d ndarray</span>
<span class="sd">        the dependent variable</span>
<span class="sd">    threshold : float</span>
<span class="sd">                the density threshold that a box has to meet</span>
<span class="sd">    obj_function : {LENIENT1, LENIENT2, ORIGINAL}</span>
<span class="sd">                   the objective function used by PRIM. Defaults to a</span>
<span class="sd">                   lenient objective function based on the gain of mean</span>
<span class="sd">                   divided by the loss of mass.</span>
<span class="sd">    peel_alpha : float, optional</span>
<span class="sd">                 parameter controlling the peeling stage (default = 0.05).</span>
<span class="sd">    paste_alpha : float, optional</span>
<span class="sd">                  parameter controlling the pasting stage (default = 0.05).</span>
<span class="sd">    mass_min : float, optional</span>
<span class="sd">               minimum mass of a box (default = 0.05).</span>
<span class="sd">    threshold_type : {ABOVE, BELOW}</span>
<span class="sd">                     whether to look above or below the threshold value</span>
<span class="sd">    mode : {RuleInductionType.BINARY, RuleInductionType.REGRESSION}, optional</span>
<span class="sd">            indicated whether PRIM is used for regression, or for scenario</span>
<span class="sd">            classification in which case y should be a binary vector</span>
<span class="sd">    update_function = {&#39;default&#39;, &#39;guivarch&#39;}, optional</span>
<span class="sd">                      controls behavior of PRIM after having found a</span>
<span class="sd">                      first box. use either the default behavior were</span>
<span class="sd">                      all points are removed, or the procedure</span>
<span class="sd">                      suggested by guivarch et al (2016)</span>
<span class="sd">                      doi:10.1016/j.envsoft.2016.03.006 to simply set</span>
<span class="sd">                      all points to be no longer of interest (only</span>
<span class="sd">                      valid in binary mode).</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :mod:`cart`</span>


<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> points remaining, containing </span><span class="si">{1}</span><span class="s2"> cases of interest&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span>
                 <span class="n">obj_function</span><span class="o">=</span><span class="n">PRIMObjectiveFunctions</span><span class="o">.</span><span class="n">LENIENT1</span><span class="p">,</span>
                 <span class="n">peel_alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">paste_alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">mass_min</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                 <span class="n">threshold_type</span><span class="o">=</span><span class="n">ABOVE</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">sdutil</span><span class="o">.</span><span class="n">RuleInductionType</span><span class="o">.</span><span class="n">BINARY</span><span class="p">,</span>
                 <span class="n">update_function</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">{</span><span class="n">sdutil</span><span class="o">.</span><span class="n">RuleInductionType</span><span class="o">.</span><span class="n">BINARY</span><span class="p">,</span>
                        <span class="n">sdutil</span><span class="o">.</span><span class="n">RuleInductionType</span><span class="o">.</span><span class="n">REGRESSION</span><span class="p">}</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_mode</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">update_function</span><span class="p">)</span>
        <span class="c1"># preprocess x</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;scenario&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">x_float</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_float</span> <span class="o">=</span> <span class="n">x_float</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_float_colums</span> <span class="o">=</span> <span class="n">x_float</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>

        <span class="n">x_int</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_int</span> <span class="o">=</span> <span class="n">x_int</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_int_columns</span> <span class="o">=</span> <span class="n">x_int</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_numeric_columns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x_float_colums</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">x_int_columns</span><span class="p">])</span>

        <span class="n">x_nominal</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

        <span class="c1"># filter out dimensions with only single value</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">x_nominal</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">column</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">((</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> dropped from analysis &quot;</span>
                              <span class="s2">&quot;because only a single category&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>

        <span class="n">x_nominal</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_nominal</span> <span class="o">=</span> <span class="n">x_nominal</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_nominal_columns</span> <span class="o">=</span> <span class="n">x_nominal</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_nominal_columns</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_yi_remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">[</span><span class="n">update_function</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">PrimException</span><span class="p">(</span><span class="s2">&quot;y is not a 1-d array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">PrimException</span><span class="p">(</span><span class="s2">&quot;len(y) != len(x)&quot;</span><span class="p">)</span>

        <span class="c1"># store the remainder of the parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paste_alpha</span> <span class="o">=</span> <span class="n">paste_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peel_alpha</span> <span class="o">=</span> <span class="n">peel_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass_min</span> <span class="o">=</span> <span class="n">mass_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold_type</span> <span class="o">=</span> <span class="n">threshold_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj_functions</span><span class="p">[</span><span class="n">obj_function</span><span class="p">]</span>

        <span class="c1"># set the indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># how many data points do we have</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># how many cases of interest do we have?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_coi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_coi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span>

        <span class="c1"># initial box that contains all data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_make_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># make a list in which the identified boxes can be put</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_yi_remaining</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">boxes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">box_lim</span> <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxes</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">boxes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;coverage&#39;</span><span class="p">,</span> <span class="s1">&#39;density&#39;</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;res_dim&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="p">:</span>
            <span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">items</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">stats</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Execute one iteration of the PRIM algorithm. That is, find one</span>
<span class="sd">        box, starting from the current state of Prim.&#39;&#39;&#39;</span>
        <span class="c1"># set the indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_yi_remaining</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># make boxes already found immutable</span>
        <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="p">:</span>
            <span class="n">box</span><span class="o">.</span><span class="n">_frozen</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no data remaining&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># log how much data and how many coi are remaining</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">determine_coi</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">)))</span>

        <span class="c1"># make a new box that contains all the remaining data points</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">PrimBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">[:])</span>

        <span class="c1">#  perform peeling phase</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peel</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;peeling completed&quot;</span><span class="p">)</span>

        <span class="c1"># perform pasting phase</span>
        <span class="n">box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paste</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;pasting completed&quot;</span><span class="p">)</span>

        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;mean: </span><span class="si">{0}</span><span class="s2">, mass: </span><span class="si">{1}</span><span class="s2">, coverage: </span><span class="si">{2}</span><span class="s2">, &quot;</span>
                   <span class="s2">&quot;density: </span><span class="si">{3}</span><span class="s2"> restricted_dimensions: </span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
                                 <span class="n">box</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span>
                                 <span class="n">box</span><span class="o">.</span><span class="n">coverage</span><span class="p">,</span>
                                 <span class="n">box</span><span class="o">.</span><span class="n">density</span><span class="p">,</span>
                                 <span class="n">box</span><span class="o">.</span><span class="n">res_dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold_type</span> <span class="o">==</span> <span class="n">ABOVE</span><span class="p">)</span> <span class="o">&amp;</span>\
           <span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">mean</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">box</span>
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold_type</span> <span class="o">==</span> <span class="n">BELOW</span><span class="p">)</span> <span class="o">&amp;</span>\
                <span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">mean</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">box</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make a dump box</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">((</span><span class="s1">&#39;box does not meet threshold criteria, &#39;</span>
                          <span class="s1">&#39;value is </span><span class="si">{}</span><span class="s1">, returning dump box&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">box</span><span class="o">.</span><span class="n">mean</span><span class="p">))</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">PrimBox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">[:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">box</span>

<div class="viewcode-block" id="Prim.determine_coi">
<a class="viewcode-back" href="../../../../source/emat.analysis/prim.html#emat.analysis.Prim.determine_coi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">determine_coi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Given a set of indices on y, how many cases of interest are</span>
<span class="sd">        there in this set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices: ndarray</span>
<span class="sd">                 a valid index for y</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            the number of cases of interest.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if threshold_type is not either ABOVE or BELOW</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_type</span> <span class="o">==</span> <span class="n">ABOVE</span><span class="p">:</span>
            <span class="n">coi</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold_type</span> <span class="o">==</span> <span class="n">BELOW</span><span class="p">:</span>
            <span class="n">coi</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;threshold type is not one of ABOVE or BELOW&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coi</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_yi_remaining_default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Update yi_remaining in light of the state of the boxes</span>
<span class="sd">        associated with this prim instance.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># set the indices</span>
        <span class="n">logical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="p">:</span>
            <span class="n">logical</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_yi_remaining_guivarch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Update yi_remaining in light of the state of the boxes</span>
<span class="sd">        associated with this prim instance using the modified version</span>
<span class="sd">        from  Guivarch et al (2016) doi:10.1016/j.envsoft.2016.03.006</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># set the indices</span>
        <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_peel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Executes the peeling phase of the PRIM algorithm. Delegates</span>
<span class="sd">        peeling to data type specific helper methods.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">mass_old</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">x_float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_float</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">]</span>
        <span class="n">x_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_int</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">]</span>
        <span class="n">x_nominal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_nominal</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">]</span>

        <span class="c1"># identify all possible peels</span>
        <span class="n">possible_peels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">x_float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_float_colums</span><span class="p">,</span>
                                    <span class="s1">&#39;float&#39;</span><span class="p">),</span>
                                   <span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_int_columns</span><span class="p">,</span>
                                    <span class="s1">&#39;int&#39;</span><span class="p">),</span>
                                   <span class="p">(</span><span class="n">x_nominal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_nominal_columns</span><span class="p">,</span>
                                    <span class="s1">&#39;object&#39;</span><span class="p">)]:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">peels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peels</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="p">[</span><span class="n">possible_peels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">peels</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">possible_peels</span><span class="p">:</span>
            <span class="c1"># there is no peel identified, so return box</span>
            <span class="k">return</span> <span class="n">box</span>

        <span class="c1"># determine the scores for each peel in order</span>
        <span class="c1"># to identify the next candidate box</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">possible_peels</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">box_lim</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">non_res_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">-</span>\
                <span class="n">sdutil</span><span class="o">.</span><span class="n">_determine_nr_restricted_dims</span><span class="p">(</span><span class="n">box_lim</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">non_res_dim</span><span class="p">,</span> <span class="n">box_lim</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

        <span class="n">scores</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">obj_score</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">box_new</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="n">mass_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mass_new</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass_min</span><span class="p">)</span> <span class="o">&amp;</span>\
           <span class="p">(</span><span class="n">mass_new</span> <span class="o">&lt;</span> <span class="n">mass_old</span><span class="p">)</span> <span class="o">&amp;</span>\
           <span class="p">(</span><span class="n">obj_score</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">box</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">box_new</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peel</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else return received box</span>
            <span class="k">return</span> <span class="n">box</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_real_peel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        returns two candidate new boxes, peel along upper and lower</span>
<span class="sd">        dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box : a PrimBox instance</span>
<span class="sd">        u : str</span>
<span class="sd">            the uncertainty for which to peel</span>
<span class="sd">        j : int</span>
<span class="sd">            column for which to peel</span>
<span class="sd">        x : ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            two box lims and the associated indices</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">peels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]:</span>
            <span class="n">xj</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>

            <span class="n">peel_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peel_alpha</span>

            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                <span class="n">peel_alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">peel_alpha</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">box_peel</span> <span class="o">=</span> <span class="n">get_quantile</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">peel_alpha</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>
                <span class="n">logical</span> <span class="o">=</span> <span class="n">xj</span> <span class="o">&gt;=</span> <span class="n">box_peel</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                <span class="n">logical</span> <span class="o">=</span> <span class="n">xj</span> <span class="o">&lt;=</span> <span class="n">box_peel</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span>
            <span class="n">temp_box</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">temp_box</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">box_peel</span>
            <span class="n">peels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span> <span class="n">temp_box</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">peels</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_discrete_peel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        returns two candidate new boxes, peel along upper and lower</span>
<span class="sd">        dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box : a PrimBox instance</span>
<span class="sd">        u : str</span>
<span class="sd">            the uncertainty for which to peel</span>
<span class="sd">        j : int</span>
<span class="sd">            column for which to peel</span>
<span class="sd">        x : ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            two box lims and the associated indices</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">peels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">]:</span>
            <span class="n">peel_alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peel_alpha</span>
            <span class="n">xj</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">box_lim</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                <span class="n">peel_alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">peel_alpha</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">box_peel</span> <span class="o">=</span> <span class="n">get_quantile</span><span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">peel_alpha</span><span class="p">)</span>
            <span class="n">box_peel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">box_peel</span><span class="p">)</span>

            <span class="c1"># determine logical associated with peel value</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">box_peel</span> <span class="o">==</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">]:</span>
                    <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">xj</span> <span class="o">&gt;</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span> <span class="o">&amp;</span>\
                              <span class="p">(</span><span class="n">xj</span> <span class="o">&lt;=</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">xj</span> <span class="o">&gt;=</span> <span class="n">box_peel</span><span class="p">)</span> <span class="o">&amp;</span>\
                              <span class="p">(</span><span class="n">xj</span> <span class="o">&lt;=</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">box_peel</span> <span class="o">==</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">]:</span>
                    <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">xj</span> <span class="o">&lt;</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span> <span class="o">&amp;</span>\
                              <span class="p">(</span><span class="n">xj</span> <span class="o">&gt;=</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">xj</span> <span class="o">&lt;=</span> <span class="n">box_peel</span><span class="p">)</span> <span class="o">&amp;</span>\
                              <span class="p">(</span><span class="n">xj</span> <span class="o">&gt;=</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>

            <span class="c1"># determine value of new limit given logical</span>
            <span class="k">if</span> <span class="n">xj</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                    <span class="n">new_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
                    <span class="n">new_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xj</span><span class="p">[</span><span class="n">logical</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xj</span><span class="p">[</span><span class="n">logical</span><span class="p">])</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span>
            <span class="n">temp_box</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">box_lim</span><span class="p">)</span>
            <span class="n">temp_box</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_limit</span>
            <span class="n">peels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span> <span class="n">temp_box</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">peels</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_categorical_peel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        returns candidate new boxes for each possible removal of a</span>
<span class="sd">        single  category. So. if the box[u] is a categorical variable</span>
<span class="sd">        with 4 categories, this method will return 4 boxes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box : a PrimBox instance</span>
<span class="sd">        u : str</span>
<span class="sd">            the uncertainty for which to peel</span>
<span class="sd">        j : int</span>
<span class="sd">            column for which to peel</span>
<span class="sd">        x : ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            a list of box lims and the associated indices</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">entries</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">peels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                <span class="n">bools</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">temp_box</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">peel</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">entries</span><span class="p">)</span>
                <span class="n">peel</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="n">temp_box</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">peel</span><span class="p">,</span> <span class="n">peel</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">entries</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span>
                                                  <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">element</span> <span class="o">!=</span> <span class="n">entry</span><span class="p">:</span>
                            <span class="n">bools</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bools</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">logical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bools</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logical</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">entry</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span>
                <span class="n">peels</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span> <span class="n">temp_box</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">peels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no peels possible, return empty list</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_paste</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Executes the pasting phase of the PRIM. Delegates pasting</span>
<span class="sd">        to data type specific helper methods.&#39;&#39;&#39;</span>

        <span class="n">mass_old</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="c1"># need to break this down by dtype</span>
        <span class="n">restricted_dims</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_determine_restricted_dims</span><span class="p">(</span><span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="p">)</span>
        <span class="n">res_dim</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">restricted_dims</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># identify all possible pastes</span>
        <span class="n">possible_pastes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_float_colums</span><span class="p">,</span>
                                 <span class="s1">&#39;float&#39;</span><span class="p">),</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_int_columns</span><span class="p">,</span>
                                 <span class="s1">&#39;int&#39;</span><span class="p">),</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_nominal_columns</span><span class="p">,</span>
                                 <span class="s1">&#39;object&#39;</span><span class="p">)]:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">res_dim</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;pasting &quot;</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span>
                <span class="n">pastes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pastes</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
                                             <span class="n">restricted_dims</span><span class="p">)</span>
                <span class="p">[</span><span class="n">possible_pastes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">pastes</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">possible_pastes</span><span class="p">:</span>
                <span class="c1"># there is no peel identified, so return box</span>
                <span class="k">return</span> <span class="n">box</span>

        <span class="c1"># determine the scores for each peel in order</span>
        <span class="c1"># to identify the next candidate box</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">possible_pastes</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">box_lim</span> <span class="o">=</span> <span class="n">entry</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">non_res_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span>\
                <span class="n">sdutil</span><span class="o">.</span><span class="n">_determine_nr_restricted_dims</span><span class="p">(</span><span class="n">box_lim</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">non_res_dim</span><span class="p">,</span> <span class="n">box_lim</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

        <span class="n">scores</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">obj</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">box_new</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">entry</span>
        <span class="n">mass_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="n">mean_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">box</span><span class="o">.</span><span class="n">yi</span><span class="p">])</span>
        <span class="n">mean_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mass_new</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass_min</span><span class="p">)</span> <span class="o">&amp;</span>\
           <span class="p">(</span><span class="n">mass_new</span> <span class="o">&gt;</span> <span class="n">mass_old</span><span class="p">)</span> <span class="o">&amp;</span>\
           <span class="p">(</span><span class="n">obj</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span>\
           <span class="p">(</span><span class="n">mean_new</span> <span class="o">&gt;</span> <span class="n">mean_old</span><span class="p">):</span>
            <span class="n">box</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">box_new</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paste</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else return received box</span>
            <span class="k">return</span> <span class="n">box</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_real_paste</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">resdim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; returns two candidate new boxes, pasted along upper and</span>
<span class="sd">        lower dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box : a PrimBox instance</span>
<span class="sd">        u : str</span>
<span class="sd">            the uncertainty for which to peel</span>
<span class="sd">        x : ndarray</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            two box lims and the associated indices</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">pastes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boxlim</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">]):</span>
            <span class="n">box_paste</span> <span class="o">=</span> <span class="n">boxlim</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># box containing data candidate for pasting</span>
            <span class="n">paste_box</span> <span class="o">=</span> <span class="n">boxlim</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>
                <span class="n">paste_box</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">box_paste</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>

                <span class="n">indices</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_in_box</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">resdim</span><span class="p">],</span> <span class="n">paste_box</span><span class="p">[</span><span class="n">resdim</span><span class="p">])</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>

                <span class="n">paste_value</span> <span class="o">=</span> <span class="n">minimum</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">paste_value</span> <span class="o">=</span> <span class="n">get_quantile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">paste_alpha</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">paste_value</span> <span class="o">&lt;=</span> <span class="n">boxlim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># direction == &#39;upper&#39;:</span>
                <span class="n">paste_box</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">paste_box</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">],</span> <span class="n">maximum</span>

                <span class="n">indices</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_in_box</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">resdim</span><span class="p">],</span> <span class="n">paste_box</span><span class="p">[</span><span class="n">resdim</span><span class="p">])</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>

                <span class="n">paste_value</span> <span class="o">=</span> <span class="n">maximum</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">paste_value</span> <span class="o">=</span> <span class="n">get_quantile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paste_alpha</span><span class="p">)</span>

                <span class="k">assert</span> <span class="n">paste_value</span> <span class="o">&gt;=</span> <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="n">box_paste</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
                <span class="n">paste_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">paste_value</span><span class="p">)</span>

            <span class="n">box_paste</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">paste_value</span>
            <span class="n">logical</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_in_box</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">resdim</span><span class="p">],</span> <span class="n">box_paste</span><span class="p">[</span><span class="n">resdim</span><span class="p">])</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">[</span><span class="n">logical</span><span class="p">]</span>

            <span class="n">pastes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span> <span class="n">box_paste</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">pastes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_categorical_paste</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">resdim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Return a list of pastes, equal to the number of classes currently</span>
<span class="sd">        not on the box lim.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        box : a PrimBox instance</span>
<span class="sd">        u : str</span>
<span class="sd">            the uncertainty for which to peel</span>
<span class="sd">        x : ndarray</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            a list of box lims and the associated indices</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">box_lim</span> <span class="o">=</span> <span class="n">box</span><span class="o">.</span><span class="n">box_lims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">c_in_b</span> <span class="o">=</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>
        <span class="n">c_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">box_init</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_in_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_t</span><span class="p">):</span>
            <span class="n">pastes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">possible_cs</span> <span class="o">=</span> <span class="n">c_t</span> <span class="o">-</span> <span class="n">c_in_b</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">possible_cs</span><span class="p">:</span>
                <span class="n">paste</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c_in_b</span><span class="p">)</span>
                <span class="n">paste</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

                <span class="n">box_paste</span> <span class="o">=</span> <span class="n">box_lim</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">box_paste</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">paste</span><span class="p">,</span> <span class="n">paste</span><span class="p">]</span>

                <span class="n">indices</span> <span class="o">=</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">_in_box</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">resdim</span><span class="p">],</span>
                                         <span class="n">box_paste</span><span class="p">[</span><span class="n">resdim</span><span class="p">])</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi_remaining</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="n">pastes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span> <span class="n">box_paste</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">pastes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no pastes possible, return empty list</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_lenient1_obj_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_old</span><span class="p">,</span> <span class="n">y_new</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        the default objective function used by prim, instead of the</span>
<span class="sd">        original objective function, This function can cope with</span>
<span class="sd">        continuous, integer, and categorical uncertainties. The basic</span>
<span class="sd">        idea is that the gain in mean is divided by the loss in mass.</span>

<span class="sd">        .. math::</span>

<span class="sd">            obj = \frac</span>
<span class="sd">                 {\text{ave} [y_{i}\mid x_{i}\in{B-b}] - \text{ave} [y\mid x\in{B}]}</span>
<span class="sd">                 {|n(y_{i})-n(y)|}</span>

<span class="sd">        where :math:`B-b` is the set of candidate new boxes, :math:`B`</span>
<span class="sd">        the old box and :math:`y` are the y values belonging to the old</span>
<span class="sd">        box. :math:`n(y_{i})` and :math:`n(y)` are the cardinality of</span>
<span class="sd">        :math:`y_{i}` and :math:`y` respectively. So, this objective</span>
<span class="sd">        function looks for the difference between  the mean of the old</span>
<span class="sd">        box and the new box, divided by the change in the  number of</span>
<span class="sd">        data points in the box. This objective function offsets a</span>
<span class="sd">        problem in case of categorical data where the normal objective</span>
<span class="sd">        function often results in boxes mainly based on the categorical</span>
<span class="sd">        data.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mean_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_old</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mean_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_new</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">mean_old</span> <span class="o">!=</span> <span class="n">mean_new</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_new</span> <span class="o">-</span> <span class="n">mean_old</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">y_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_new</span> <span class="o">-</span> <span class="n">mean_old</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PrimException</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&#39;&#39;&#39;mean is different {} vs {}, while shape is the same,</span>
<span class="sd">                                       this cannot be the case&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">mean_old</span><span class="p">,</span> <span class="n">mean_new</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_lenient2_obj_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_old</span><span class="p">,</span> <span class="n">y_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        friedman and fisher 14.6</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mean_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_old</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mean_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_new</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">mean_old</span> <span class="o">!=</span> <span class="n">mean_new</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y_old</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PrimException</span><span class="p">(</span>
<span class="w">                    </span><span class="sd">&#39;&#39;&#39;mean is different {} vs {}, while shape is the same,</span>
<span class="sd">                                       this cannot be the case&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">mean_old</span><span class="p">,</span> <span class="n">mean_new</span><span class="p">))</span>

            <span class="n">change_mean</span> <span class="o">=</span> <span class="n">mean_new</span> <span class="o">-</span> <span class="n">mean_old</span>
            <span class="n">change_mass</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y_old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">mass_new</span> <span class="o">=</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">obj</span> <span class="o">=</span> <span class="n">mass_new</span> <span class="o">*</span> <span class="n">change_mean</span> <span class="o">/</span> <span class="n">change_mass</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_original_obj_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_old</span><span class="p">,</span> <span class="n">y_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; The original objective function: the mean of the data</span>
<span class="sd">        inside the box&#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">y_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">update_function</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">sdutil</span><span class="o">.</span><span class="n">RuleInductionType</span><span class="o">.</span><span class="n">BINARY</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">==</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">update_function</span> <span class="o">==</span> <span class="s1">&#39;guivarch&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        helper fucntion that checks whether none of the provided keys</span>
<span class="sd">        has a dtype object as value.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dtypes</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">EMAError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has dtype object and can thus not be rotated&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">_peels</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;object&#39;</span><span class="p">:</span> <span class="n">_categorical_peel</span><span class="p">,</span>
              <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="n">_discrete_peel</span><span class="p">,</span>
              <span class="s1">&#39;float&#39;</span><span class="p">:</span> <span class="n">_real_peel</span><span class="p">}</span>

    <span class="n">_pastes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;object&#39;</span><span class="p">:</span> <span class="n">_categorical_paste</span><span class="p">,</span>
               <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="n">_real_paste</span><span class="p">,</span>
               <span class="s1">&#39;float&#39;</span><span class="p">:</span> <span class="n">_real_paste</span><span class="p">}</span>

    <span class="c1"># dict with the various objective functions available</span>
    <span class="c1"># todo:: move functions themselves to ENUM?</span>
    <span class="n">_obj_functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">PRIMObjectiveFunctions</span><span class="o">.</span><span class="n">LENIENT2</span><span class="p">:</span> <span class="n">_lenient2_obj_func</span><span class="p">,</span>
                      <span class="n">PRIMObjectiveFunctions</span><span class="o">.</span><span class="n">LENIENT1</span><span class="p">:</span> <span class="n">_lenient1_obj_func</span><span class="p">,</span>
                      <span class="n">PRIMObjectiveFunctions</span><span class="o">.</span><span class="n">ORIGINAL</span><span class="p">:</span> <span class="n">_original_obj_func</span><span class="p">}</span>

    <span class="n">_update_functions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">_update_yi_remaining_default</span><span class="p">,</span>
                         <span class="s1">&#39;guivarch&#39;</span><span class="p">:</span> <span class="n">_update_yi_remaining_guivarch</span><span class="p">}</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>